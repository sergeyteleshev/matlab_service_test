
%factor_p - Коэффициент использования системы
%factor_Tq - Среднее время ожидания завки в очереди
%factor_Ts - Среднее время пребывания завки в системе
%factor_Nq - Среднее по времени число требований в очереди
%factor_Ns - Среднее по времени число требований в системе
%factor_C - Абсолютная пропускная способность системы
%factor_Cr - Относительная пропускная способность системы

%T - Массив модального времени
%U_condition - Массив состояний устройств
%Q_amount=[0] - Массив чисел требований в очереди - необходим для графика

%А - время между поступлениями требований
%S - время обработки требований    
%device_number - количество устройств обработки
%queue_max - длина очереди


function [factor_p, factor_Tq, factor_Ts, factor_Nq, factor_Ns, factor_Ca, factor_Cr, T, U_condition, Q_amount] = modelSystem(A, S, Pr, device_number, queue_max)

    
    %Инициализация переменных
    
    U=zeros(1, device_number);           %Массив устройств -  время
    U_priority=zeros(1, device_number);  %Массив устройств - приоритеты
    T=[0];                               %Массив модального времени
    Int=[];                              %Массив интервалов времени
    Q=[];                                %Массив очереди - время выполнения заявок S(i)
    Q_current=[];                        %Массив очереди - порядковые номера заявок i 
    Q_priority=[];                       %Массив очереди - приоритеты заявок

    
    p=zeros(1, device_number); %Время, которое каждое устройство находилось в состоянии обработки заявки
    d=[];                      %Время пребывания каждой заявки в очереди
    
    
    n=length(A);               %Общее число поступивших в систему требований
    fail=0;                    %Количество отказов
    
    Q_amount=[0];              %Массив чисел требований в очереди - необходим для графика
    S_amount=[0];              %Массив чисел требований в системе - необходим для графика
    dn=[];                     %Массив среднего время ожидания заявки в очереди - необходим для графика
    sn=[];                     %Массив среднего время пребывания заявки в системе - необходим для графика
    p_current=[0];             %Массив текущих коэффициентов системы - необходим для графика
    
    
    U_condition(1,:)=[U];      %Массив состояний устройств - необходим для визуализации
     
    i=1;                       %Переменная порядкового номера текущей заявки
    
    disp('НАЧАЛО РАБОТЫ СИСТЕМЫ');
    disp('ПОСТУПЛЕНИЕ ЗАЯВОК В СИСТЕМУ');
    while i<=n
    %%%%%%%Определение следующего события: поступление новой заявки(А(i)) или
    %%%%%%%выполнение текущей (S_MIN)
        %
        %
        % Нахождение максимального элемента среди двух сгенерированных массивов
        S_MIN = max([A,S])+1;

        % Если какое-то из устройств занято...
        if ~isempty(U(U>0))
           S_MIN = min(U(U>0));
        end

        %Сравнение S_MIN и времени поступления новой заявки
        
        
        if S_MIN < A(i)  %Следующее событие - выполнение имеющейся заявки
            
            
            %Изменение текущего времени
            Int(end+1)=S_MIN;
            T(end+1)=T(end)+S_MIN;
            
            
            
            %Измение времени появления следующей заявки
            A(i)=A(i)-S_MIN;
            
            %Сбор статистики d
            for k = 1:1:length(Q_current)
                     d(Q_current(k))=d(Q_current(k))+S_MIN;
            end
            
            %Поиск номера устройства, на котором выполнится заявка
            j = find(U==min(U(U>0)));
            
            %Обнуление приоритета
            U_priority(j(1))=0;
            
            %Изменение времени на всех устройствах
            for k = 1:1:length(U)
                 if U(k)>0 & (length(Int)>1)
                     U(k)=U(k)-S_MIN;
                     %Сбор статистики p
                     p(k)=p(k)+S_MIN;
                 end
            end
            %disp(sprintf('Заявка выполнена на устройстве %g', j(1)));
            
            %Изменение числа требований в системе - число уменьшается:
            S_amount(end+1) = S_amount(end)-1;
            
            %Проверка очереди
            %Если очередь не пуста - добавление заявки на освободившееся
            %устройство
            if ~isempty(Q)
                U(j(1))=Q(1);
                
                U_priority(j(1))=Q_priority(1);
                %disp(sprintf('Заявка из очереди перемещена на устройство %g',j(1)));
                
                
                %Очистка очереди
                Q = Q(2:length(Q));
                Q_priority= Q_priority(2:length(Q_priority));
                Q_current = Q_current(2:length(Q_current));
               
                [Q, Q_priority, Q_current] = sortQueue(Q, Q_priority, Q_current);                
                
                %Изменение числа требований в очереди - число уменьшается
                Q_amount(end+1) = Q_amount(end)-1;
                
            else
                %Число требований в очереди не меняется:
                Q_amount(end+1) = Q_amount(end);
            end
           
            %Подсчет текущего коэффициента использования системы
            p_current(end+1) = sum(p/T(end))/length(p);
            
            
            %Фиксирование состояний системы
            U_condition(end+1,:)=U_priority;

        else  %Следующее событие - поступление новой заявки
            
            %Изменение статистики d
            for k = 1:1:length(Q_current)
                d(Q_current(k))=d(Q_current(k))+A(i);
            end

            %Изменение времени на всех устройствах
            for k = 1:1:length(U)
                 if U(k)>0 
                     U(k)=U(k)-A(i);
                     
                     %Сбор статистики p
                     p(k)=p(k)+A(i);
                 end
            end
            
            
            %%Проверка свободных устройств
            if ~all(U) %Если есть хоть один 0 в массиве U - устройтво свободно
                
                %Поиск свободного устройства
                k = find(U==min(U));
                U(k(1))=S(i);
                U_priority(k(1))=Pr(i);
                
                %disp(sprintf('Есть свободное устройство! Заявка отправлена на устройство %g.', k(1)));

                %Сбор статистики d - добавление нового элемента в массив
                d(i)=0;
                
                %Изменение числа требований в системе - число увеличивается:
                S_amount(end+1) = S_amount(end)+1;
                
                %Число требований в очереди не меняется:
                Q_amount(end+1) = Q_amount(end);
                
                %Переход к следующей заявке
                i=i+1;
                
            else
                %disp('Нет свободного устройства')
                if length(Q) < queue_max %Проверка очереди
                    
                    %Вытеснение заявки в очередь(Добавление в начало)
                    Q=[S(i),Q];
                    Q_current=[i,Q_current];
                    Q_priority=[Pr(i),Q_priority];
                    %disp(sprintf('Заявка c более низким приоритетом перемещена в очередь. Осталось мест в очереди: %g', queue_max-length(Q)))


                    %Добавление важной заявки на устройство
                    %U(k(1))=S(i);
                    %U_priority(k(1))=Pr(i);

                    %Сбор статистики d - добавление нового элемента в массив
                    d(i)=0;

                    %Изменение числа требований в системе - число увеличивается:
                    S_amount(end+1) = S_amount(end)+1;

                    %Изменение числа требований в очереди - число увеличивается:
                    Q_amount(end+1) = Q_amount(end)+1;
                else
                    %disp('Очередь переполнена. Заявка будет перемещена в отказы');


                    %Добавление важной заявки на устройство

                    %U(k(1))=S(i);
                    %U_priority(k(1))=Pr(i);

                    %Сбор статистики fail - количество отказов
                    fail=fail+1;

                    %Сбор статистики d - добавление нового элемента в массив
                    d(i)=0;

                    %Число требований в системе не меняется:
                    S_amount(end+1) = S_amount(end);

                    %Число требований в очереди не меняется:
                    Q_amount(end+1) = Q_amount(end);

                end%Проверка очереди

                %Переход к следующей заявке
                i=i+1;

            end
            
            
        
            %Фиксирование состояний системы
            
            U_condition(end+1,:)=U_priority;
            
            %Подсчет текущего коэффициента использования системы
            p_current(end+1) = sum(p/T(end))/length(p);
            
            %Изменение модельного времени
            T(end+1)=T(end)+A(i-1);
            Int(end+1)=A(i-1);


        end %событие
    end% конец цикла
    disp('ОКОНЧАНИЕ МОДЕЛЬНОГО ВРЕМЕНИ - ЗАВЕРШЕНИЕ ПОСТУПЛЕНИЯ ЗАЯВОК В СИСТЕМУ');
    
    %Обработка оставшихся заявок в системе:
    disp('ОБРАБОТКА ОСТАВШИХСЯ ЗАЯВОК В СИСТЕМЕ:');

    while max(U)>0 %Пока есть свободное устройство
        
        %Поиск минимального времени выполнения
        S_MIN = min(U(U>0));
        
        %Изменение модельного времени
        Int(length(Int)+1)=S_MIN;
        T(length(T)+1)=T(length(T))+S_MIN;
        
        %Изменение статистики d
        for k = 1:1:length(Q_current)
            d(Q_current(k))=d(Q_current(k))+S_MIN;
        end
        
        %Поиск номера устройства, на котором выполнится заявка
        j = find(U==min(U(U>0)));
            
        %Обнуление приоритета
        U_priority(j(1))=0;

        %Изменение времени на всех устройствах
        for k = 1:1:length(U)
                 if U(k)>0 & (length(Int)>1)
                     U(k)=U(k)-Int(length(Int));
                     %Сбор статистики p
                     p(k)=p(k)+Int(length(Int));
                 end
        end
        
        %disp(sprintf('Заявка выполнена на устройстве %g', j(1)));
        
        %Изменение числа требований в системе - число уменьшается:
        S_amount(end+1) = S_amount(end)-1;

        %Проверка очереди
        %Если очередь не пуста - добавление заявки на освободившееся
        %устройство
        if ~isempty(Q)
            U(j(1))=Q(1);
                
            U_priority(j(1))=Q_priority(1);
            
            %disp(sprintf('Заявка из очереди перемещена на устройство %g',j(1)));
                
            %Очистка очереди
            Q = Q(2:length(Q));
            Q_current = Q_current(2:length(Q_current));
            Q_priority= Q_priority(2:length(Q_priority));
            
            [Q, Q_priority, Q_current] = sortQueue(Q, Q_priority, Q_current);
            
            %Изменение числа требований в очереди - число уменьшается
            Q_amount(end+1) = Q_amount(end)-1;
            
        else
            
            %Число требований в очереди не меняется:
            Q_amount(end+1) = Q_amount(end);
            
        end
        
        %Фиксирование состояний системы
        U_condition(end+1,:)=U_priority;
        
        
        %Подсчет текущего коэффициента использования системы
        p_current(end+1) = sum(p/T(end))/length(p);

    end
    disp('ЗАВЕРШЕНИЕ РАБОТЫ СИСТЕМЫ');
    %U_condition
    disp('=======================================');
    disp('ОБРАБОТКА РЕЗУЛЬТАТОВ');
    disp('=======================================');
    
    
    up=p/(T(end));                                                   %Относительная занятость устройств
    factor_p = sum(up)/length(up);                                   %Коэффициент использования системы
    factor_Tq = sum(d)/length(d);                                    %Среднее время ожидания завки в очереди
    factor_Ts = sum(d+S(1:length(d)))/length(d);                     %Среднее время пребывания завки в системе
    factor_Nq = sum(d)/length(d)/(sum(A)/length(A));                 %Среднее по времени число требований в очереди
    factor_Ns = sum(d+S(1:length(d)))/length(d)/(sum(A)/length(A));  %Среднее по времени число требований в системе
    factor_Ca = (length(A)-fail)/T(end);                             %Абсолютная пропускная способность системы
    factor_Cr = (length(A)-fail)/length(A);                          %Относительная пропускная способность системы
    

    disp(sprintf('Общее время моделирования: Т = %g секунд',T(end)));
    
    disp(sprintf('Коэффициент системы: %g',factor_p));
    disp(sprintf('Среднее время ожидания завки в очереди: %g',factor_Tq));
    disp(sprintf('Среднее время пребывания завки в системе: %g',factor_Ts));
    disp(sprintf('Среднее по времени число требований в очереди: %g',factor_Nq));
    disp(sprintf('Среднее по времени число требований в системе: %g',factor_Ns));
    disp(sprintf('Абсолютная пропускная способность системы: %g',factor_Ca));
    disp(sprintf('Относительная пропускная способность системы: %g',factor_Cr));
    
    disp(sprintf('Математическое ожидание А: %g',(sum(A)/length(A))));
    disp(sprintf('Математическое ожидание S: %g',(sum(S)/length(S))));
   
    %Графики
    
    %Число требований в очереди   
    Qn=[];    
%     for i=1:1:length(T)
%         Qn(i)=sum(Q_amount(1:i))/i;
%     end
            
    %Число требований в системе   
    Sn=[];
%     for i=1:1:length(T)
%        Sn(i)=sum(S_amount(1:i))/i;
%     end
            
    %Среднее время ожидания заявки в очереди
    for i=1:1:n
        dn(i)=sum(d(1:i))/i;
    end    
    
    %Среднее время пребывания заявки в системе
    for i=1:1:n
       sn(i)=dn(i)+sum(S(1:i))/i;
    end            
    
    global g_Qn g_T g_Sn g_dn g_n g_sn g_p_current visualize;
    g_Sn = S_amount;   
    g_Qn = Q_amount;
    g_T = T;    
    g_dn = dn;
    g_n = n;
    g_sn = sn;
    g_p_current = p_current;
    visualize = true;        
end   